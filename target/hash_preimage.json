{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"13133489487543597318","abi":{"parameters":[{"name":"word","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"word_length","type":{"kind":"field"},"visibility":"public"},{"name":"winner","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"use dep::std;\n\n// Circuito de ahorcado que evita frontrunn y verifica que la palabra sea valida\nfn main(\n    word: [Field; 10], // Palabra a adivinar, un maximo de 10 caracteres\n    word_length: pub Field, // Longitud de la palabra, cantidad de caracteres\n    winner: pub Field, // Wallet del ganador, debe estar integrado en los parametros de la transaccion para evitar frontrunn\n) -> pub Field {\n    // Convierte la palabra a bytes para ser compatible con la implementacion de la libreria de keccak256 que usaremos\n    // Ademas, verificamos que la palabra no contenga caracteres no alfabeticos\n    let mut word_bytes = [0; 10];\n    for i in 0..10 {\n        if i < word_length as u8 {\n            let current_char = word[i] as u8;\n            let is_uppercase = (current_char >= 65) & (current_char <= 90);\n            let is_lowercase = (current_char >= 97) & (current_char <= 122);\n            assert(is_uppercase | is_lowercase);\n        }\n        word_bytes[i] = word[i] as u8;\n    }\n\n    // Obtenemos el hash de la palabra\n\n    let hash_bytes = std::hash::blake3(word_bytes);\n\n    // Convertimos el hash a un numero de 256 bits para ahorrar el tamano de la prueba\n    let mut computed_hash = 0 as Field;\n    for i in 0..30 {\n        computed_hash = computed_hash * 256 + (hash_bytes[i] as Field);\n    }\n\n    println(computed_hash);\n    println(hash_bytes);\n    // Devolvemos el hash de la palabra, recuerda que los valores de retorno son parametros publicos en el contrato\n    computed_hash\n}\n","path":"/Users/GermanKuber/Documents/Repositories/noir/hash_preimage/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","directive_integer_quotient","directive_invert"]}